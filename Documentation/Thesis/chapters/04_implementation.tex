% !TeX root = ../main.tex
\chapter{Implementation}
\warn{\begin{itemize}
	\item Parser for problem (not verified) into AST
	\item Ab+La as input format
\end{itemize}}
\section{Datatype Representation}
\warn{Ab+La specifics:
\begin{itemize}
	\item term: Union of variable and constant.
	\item instance with only constant terms is essentially already grounded.
	\item Formula atoms: either facts or Eq
	\item e.g. effects are "atom formula list" in favor of "PredAtom list". Restricted to list of facts by wf, not by types
	\item Either-type consts
	\item wrapper classes to ensure safety (can't confuse variable and const)
	\item objectT
	\item Closed-world and Entailment/Valuation!
\end{itemize}}
\section{Input Restriction}
\warn{\begin{itemize}
	\item single-typed constants + explanation. What if we don't restrict this --> example of what would be necessary to still normalize the types
	\item Well-formed action parameter types (potentially an oversight). Technically not necessary: Actions and thus their preconds/effects have to be wf. So if a param isn't wf, then the precond and effect do not reference that parameter. There's probably a way to leverage that, but why bother.
\end{itemize}}
\section{Normalization}
\warn{\begin{itemize}
	\item The following normalizations can be applied independently of one another, but it is important that precondition normalization is applied last, since type normalization and goal normalization respectively modify preconditions or add actions alltogether.
	\item each normalization step preserves some properties of the input problem (input lemmas \todo{think of a name}) and modifies it to create an output with desired properties.
	\item For each one: prerequisites? output props, kept input props, semantics
\end{itemize}}
\subsection{Type Normalization}
\warn{\begin{itemize}
	\item Create instance where only type is ``object''
	\item unique predicate names
	\item generate supertype facts
	\item reachable nodes algorithm
	\item generate param preconds. If action params were allowed to not be wf, then action would not have valid instantiations, thus precond could just be False instead.
	\item remove types
	\item easier for me because no forall in effects
	\item Main theorem: equivalence of semantics
\end{itemize}}
\subsection{Goal Normalization}
\warn{\begin{itemize}
	\item Originally, axioms are required to manage disjunctions, so this alternative method is used.
	\item This could be part of formula normalization, but this method was simply easier.
	\item The goal is functionally replaced with a new dummy action
	\item New goal predicate. No parameters -> true binary variable
	\item Goal moved into precondition of new goal action that has no parameters. The effect is simply setting the goal variable to true.
	\item The new goal is simply only the goal variable.
\end{itemize}}
\subsection{Precondition Normalization}
\warn{\begin{itemize}
	\item Turn each formula into DNF, then split across disjunctions
	\item Operator ID organization
	\item Main theorem: equivalence of semantics w.r.t. corresponding actions.
\end{itemize}}

\section{Reachability Analysis}
\subsection{Relaxed Task Generation}
\warn{\begin{itemize}
	\item requirement: preconditions + goal must be pure conjunctions
	\item resulting preconditions (and goal) must really be relaxed: ENTAILMENT
	\item Just remove negative literals in preconditions (and goal)
	\item Mention the issue with STRIPS formulas: Not compatible with Datalog, also difficult to find "weaker" formula.
	\item \todo{Find term for a modification of a formula that is relaxed, i.e. for every world model, sat OG ==> sat new.}
	\item Main theorem: reachable states are superset of OGs
	
\end{itemize}}
\subsection{Datalog Generation}
\warn{\begin{itemize}
	\item rules are safe due to type-predicates. (every parameter is mentioned in preconditions).
	\item If not, dummy(x) is added (MVP)
	\item Main theorem: reachable states equivalent to relaxed instance
\end{itemize}}
\subsection{Datalog Rule Decomposition}
\warn{\begin{itemize}
	\item Join/projection rules
	\item normal form
	\item Performance-critical issue: How to choose joins.
	\item Helmert's Algorithm, Correa's Heuristic
	\item [correa:] Helmert prefers atoms with many variables to join first, correa with few variables first.
	\item external datalog solver
\end{itemize}}
\subsection{Refinement: Tree Decomposition}
\warn{\begin{itemize}
	\item tree decomposition definition
	\item External algorithm (?)
	\item Algorithm external! No proof that algorithm ever terminates. BUT in principle, there is always a tree decomposition.
\end{itemize}}
\section{Grounded Instance Generation}
\warn{\begin{itemize}
	\item Interpret datalog solution: No solution -> goal not reachable
	\item Construct instance from set of reachable operators
	\item TO STRIPS: no overlap between add and del effects!
	\item STRIPS: Goal allowed to contain negative literals
	\item STRIPS: if operator isn't enabled, it does NOOP.
	\item piping into Ab+Ku solver
\end{itemize}}