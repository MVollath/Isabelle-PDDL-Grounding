% !TeX root = ../main.tex

\chapter{Introduction}\label{chapter:introduction}

Automated planning is a critical domain in artificial intelligence that deals with the generation of action sequences to achieve specified goals from a given state. Planning problems can be expressed in various languages, among which the Planning Domain Definition Language (PDDL), Simplified Action Structures (SAS), and STRIPS are particularly noteworthy.
PDDL is a higher-level, first-order language that includes concepts such as parameterized actions and predicates.
Due to its complexity, PDDL is not well-suited suited for direct input into solvers.
In contrast, STRIPS is a propositional planning language, meaning actions are not parameterized and the state consists of binary variables. Because of this simplicity, it is more feasible to design solving algorithms for tasks defined in STRIPS.
In contrast to STRIPS, \SASP is a finite-domain language, meaning variables can have more than two discrete values.

The process of transforming a task from a first-order representation into a propositional representation is grounding.
In order to obtain a solution for a PDDL task, it is usually first grounded and then fed into a solver.
A naive grounder, which simply instantiates every action and predicate with every possible combination of parameters, can be easily implemented. However, this approach leads to an exponential increase in ground variables and actions, rendering it infeasible for even modestly sized problems.

A good grounder must thus restrict the number of ground variables and actions produced. This is commonly done by employing reachability analysis, in order to omit impossible predicate and action instantiations from the ground problem. Note that it is typically infeasible to compute the exact set of reachable states or satisfiable ground actions. Instead, a superset is commonly produced.

A common grounding procedure was introduced by Helmert in 2008 and implemented as part of the Fast Downward planning system. For a relaxed version of the input PDDL task, the exact set of satisfiable actions instances is computed, using logic programming. In addition, Helmert employs an algorithm called invariant synthesis to produce finite-domain variables instead of binary ones, reducing the number of variables in the ground task. It is important to note that invariant synthesis is orthogonal to the grounding process.
Correa et al developed two refinements to the reachability analysis which reduce the complexity of the generated logic program. Firstly, tree decomposition is employed to generate a more efficient form. Secondly, the set of satisfiable action instances is computed by first calculating the set of reachable states.

While implementations of these methods are publicly available, they are not formally verified. Formally verifying them is the aim of this project.
The automated theorem prover Isabelle facilitates this process. In Isabelle, formulas and even entire programs can be expressed in a formal language. Within this framework, properties such as appropriately defined correctness specifications can then be proven. However, for this, the entire program has to be re-implemented in Isabelle, in a functional programming language similar to Haskell. Note that the correctness of an algorithm does not necessarily have anything to do with whether or not it is efficiently implemented.

While to our knowledge, no fully verified grounder exists, there are formally verified plan checkers for our languages of interest, and even a verified solver for STRIPS. One might then wonder why it is necessary to formally verify a grounder or a solver. Indeed, given a PDDL planning task, one could input it into an unverified grounder and an unverified solver, and simply verify the obtained solution with a verified plan checker.
The key difference then, however, is that if the untrusted solver does not find any solution, one cannot be certain that such a solution indeed does not exist. Only if the entire procedure is verified, we can confidently assert that a solution does not exist.
Additionally, other properties of the planning task can potentially be verified, such as the optimality of a given solution.

My contributions include the formal verification and optimization of Helmert's grounding algorithm and Correa's refinements, implemented in Isabelle. This includes formal verifications of graph algorithms that are used as subroutines: an enumeration of the transitive closure of a relation and an algorithm to produce a tree decomposition for a graph.
